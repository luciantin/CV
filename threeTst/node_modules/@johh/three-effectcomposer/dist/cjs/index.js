'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var THREE = require('three');

var CopyShader = {
  uniforms: {
    tDiffuse: {
      value: null
    },
    opacity: {
      value: 1.0
    }
  },
  vertexShader: ['varying vec2 vUv;', 'void main() {', '	vUv = uv;', '	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );', '}'].join('\n'),
  fragmentShader: ['uniform float opacity;', 'uniform sampler2D tDiffuse;', 'varying vec2 vUv;', 'void main() {', '	vec4 texel = texture2D( tDiffuse, vUv );', '	gl_FragColor = opacity * texel;', '}'].join('\n')
};

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

var camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
var geometry = new THREE.PlaneBufferGeometry(2, 2);

var _FullScreenQuad = /*#__PURE__*/function () {
  function _FullScreenQuad(material) {
    _classCallCheck(this, _FullScreenQuad);

    this._mesh = new THREE.Mesh(geometry, material);
  }

  _createClass(_FullScreenQuad, [{
    key: "render",
    value: function render(renderer) {
      renderer.render(this._mesh, camera);
    }
  }, {
    key: "material",
    get: function get() {
      return this._mesh.material;
    },
    set: function set(value) {
      this._mesh.material = value;
    }
  }]);

  return _FullScreenQuad;
}();

var Pass = /*#__PURE__*/function () {
  function Pass() {
    _classCallCheck(this, Pass);

    this.enabled = true;
    this.needsSwap = false;
    this.clear = false;
    this.renderToScreen = false;
  }

  _createClass(Pass, [{
    key: "setSize",
    value: function setSize(width, height) {}
  }, {
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer, delta, maskActive) {
      console.error('THREE.Pass: .render() must be implemented in derived pass.');
    }
  }]);

  return Pass;
}();

Pass.FullScreenQuad = _FullScreenQuad;

var ShaderPass = /*#__PURE__*/function (_Pass) {
  _inherits(ShaderPass, _Pass);

  var _super = _createSuper(ShaderPass);

  function ShaderPass(shader, textureID) {
    var _this;

    _classCallCheck(this, ShaderPass);

    _this = _super.call(this);
    _this.textureID = textureID !== undefined ? textureID : 'tDiffuse';

    if (shader instanceof THREE.ShaderMaterial) {
      _this.uniforms = shader.uniforms;
      _this.material = shader;
    } else if (shader) {
      _this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
      _this.material = new THREE.ShaderMaterial({
        defines: Object.assign({}, shader.defines),
        uniforms: _this.uniforms,
        vertexShader: shader.vertexShader,
        fragmentShader: shader.fragmentShader
      });
    }

    _this.fsQuad = new Pass.FullScreenQuad(_this.material);
    return _this;
  }

  _createClass(ShaderPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer) {
      if (this.uniforms[this.textureID]) {
        this.uniforms[this.textureID].value = readBuffer.texture;
      }

      this.fsQuad.material = this.material;

      if (this.renderToScreen) {
        renderer.setRenderTarget(null);
        this.fsQuad.render(renderer);
      } else {
        renderer.setRenderTarget(writeBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

        if (this.clear) {
          renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
        }

        this.fsQuad.render(renderer);
      }
    }
  }]);

  return ShaderPass;
}(Pass);

var RenderingPass = /*#__PURE__*/function (_Pass) {
  _inherits(RenderingPass, _Pass);

  var _super = _createSuper(RenderingPass);

  function RenderingPass() {
    var _this;

    _classCallCheck(this, RenderingPass);

    _this = _super.call(this);
    _this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
    _this.scene = new THREE.Scene();
    _this.quad = new THREE.Mesh(new THREE.PlaneBufferGeometry(2, 2), null);
    _this.quad.frustumCulled = false;

    _this.scene.add(_this.quad);

    return _this;
  }

  return RenderingPass;
}(Pass);

var TexturePass = /*#__PURE__*/function (_Pass) {
  _inherits(TexturePass, _Pass);

  var _super = _createSuper(TexturePass);

  function TexturePass(map, opacity) {
    var _this;

    _classCallCheck(this, TexturePass);

    _this = _super.call(this);
    var shader = CopyShader;
    _this.map = map;
    _this.opacity = opacity !== undefined ? opacity : 1.0;
    _this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
    _this.material = new THREE.ShaderMaterial({
      uniforms: _this.uniforms,
      vertexShader: shader.vertexShader,
      fragmentShader: shader.fragmentShader,
      depthTest: false,
      depthWrite: false
    });
    _this.needsSwap = false;
    _this.fsQuad = new Pass.FullScreenQuad(null);
    return _this;
  }

  _createClass(TexturePass, [{
    key: "render",
    value: function render(_renderer, writeBuffer, readBuffer) {
      var renderer = _renderer;
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      this.fsQuad.material = this.material;
      this.uniforms.opacity.value = this.opacity;
      this.uniforms.tDiffuse.value = this.map;
      this.material.transparent = this.opacity < 1.0;
      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
      if (this.clear) renderer.clear();
      this.fsQuad.render(renderer);
      renderer.autoClear = oldAutoClear;
    }
  }]);

  return TexturePass;
}(Pass);

var RenderPass = /*#__PURE__*/function (_Pass) {
  _inherits(RenderPass, _Pass);

  var _super = _createSuper(RenderPass);

  function RenderPass(scene, camera, overrideMaterial, clearColor, clearAlpha) {
    var _this;

    _classCallCheck(this, RenderPass);

    _this = _super.call(this);
    _this.scene = scene;
    _this.camera = camera;
    _this.overrideMaterial = overrideMaterial;
    _this.clearColor = clearColor;
    _this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
    _this.clear = true;
    _this.clearDepth = false;
    _this.needsSwap = false;
    return _this;
  }

  _createClass(RenderPass, [{
    key: "render",
    value: function render(_renderer, writeBuffer, readBuffer) {
      var renderer = _renderer;
      var oldAutoClear = renderer.autoClear;
      renderer.autoClear = false;
      this.scene.overrideMaterial = this.overrideMaterial;
      var oldClearColor;
      var oldClearAlpha;

      if (this.clearColor) {
        oldClearColor = renderer.getClearColor().getHex();
        oldClearAlpha = renderer.getClearAlpha();
        renderer.setClearColor(this.clearColor, this.clearAlpha);
      }

      if (this.clearDepth) {
        renderer.clearDepth();
      }

      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer); // TODO: Avoid using autoClear properties, see https://github.com/mrdoob/three.js/pull/15571#issuecomment-465669600

      if (this.clear) {
        renderer.clear(renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil);
      }

      renderer.render(this.scene, this.camera);

      if (this.clearColor) {
        renderer.setClearColor(oldClearColor, oldClearAlpha);
      }

      this.scene.overrideMaterial = null;
      renderer.autoClear = oldAutoClear;
    }
  }]);

  return RenderPass;
}(Pass);

var MaskPass = /*#__PURE__*/function (_Pass) {
  _inherits(MaskPass, _Pass);

  var _super = _createSuper(MaskPass);

  function MaskPass(scene, camera) {
    var _this;

    _classCallCheck(this, MaskPass);

    _this = _super.call(this);
    _this.scene = scene;
    _this.camera = camera;
    _this.clear = true;
    _this.needsSwap = false;
    _this.inverse = false;
    return _this;
  }

  _createClass(MaskPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer) {
      var context = renderer.context,
          state = renderer.state; // don't update color or depth

      state.buffers.color.setMask(false);
      state.buffers.depth.setMask(false); // lock buffers

      state.buffers.color.setLocked(true);
      state.buffers.depth.setLocked(true); // set up stencil

      var writeValue;
      var clearValue;

      if (this.inverse) {
        writeValue = 0;
        clearValue = 1;
      } else {
        writeValue = 1;
        clearValue = 0;
      }

      state.buffers.stencil.setTest(true);
      state.buffers.stencil.setOp(context.REPLACE, context.REPLACE, context.REPLACE);
      state.buffers.stencil.setFunc(context.ALWAYS, writeValue, 0xffffffff);
      state.buffers.stencil.setClear(clearValue); // draw into the stencil buffer

      renderer.setRenderTarget(readBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera);
      renderer.setRenderTarget(writeBuffer);
      if (this.clear) renderer.clear();
      renderer.render(this.scene, this.camera); // unlock color and depth buffer for subsequent rendering

      state.buffers.color.setLocked(false);
      state.buffers.depth.setLocked(false); // only render where stencil is set to 1

      state.buffers.stencil.setFunc(context.EQUAL, 1, 0xffffffff); // draw if == 1

      state.buffers.stencil.setOp(context.KEEP, context.KEEP, context.KEEP);
    }
  }]);

  return MaskPass;
}(Pass);

var ClearMaskPass = /*#__PURE__*/function (_Pass) {
  _inherits(ClearMaskPass, _Pass);

  var _super = _createSuper(ClearMaskPass);

  function ClearMaskPass() {
    var _this;

    _classCallCheck(this, ClearMaskPass);

    _this = _super.call(this);
    _this.needsSwap = false;
    return _this;
  }

  _createClass(ClearMaskPass, [{
    key: "render",
    value: function render(renderer) {
      renderer.state.buffers.stencil.setTest(false);
    }
  }]);

  return ClearMaskPass;
}(Pass);

var ClearPass = /*#__PURE__*/function (_Pass) {
  _inherits(ClearPass, _Pass);

  var _super = _createSuper(ClearPass);

  function ClearPass(clearColor, clearAlpha) {
    var _this;

    _classCallCheck(this, ClearPass);

    _this = _super.call(this);
    _this.needsSwap = false;
    _this.clearColor = clearColor !== undefined ? clearColor : 0x000000;
    _this.clearAlpha = clearAlpha !== undefined ? clearAlpha : 0;
    return _this;
  }

  _createClass(ClearPass, [{
    key: "render",
    value: function render(renderer, writeBuffer, readBuffer) {
      var oldClearColor;
      var oldClearAlpha;

      if (this.clearColor) {
        oldClearColor = renderer.getClearColor().getHex();
        oldClearAlpha = renderer.getClearAlpha();
        renderer.setClearColor(this.clearColor, this.clearAlpha);
      }

      renderer.setRenderTarget(this.renderToScreen ? null : readBuffer);
      renderer.clear();

      if (this.clearColor) {
        renderer.setClearColor(oldClearColor, oldClearAlpha);
      }
    }
  }]);

  return ClearPass;
}(Pass);

var EffectComposer = /*#__PURE__*/function () {
  function EffectComposer(renderer, _renderTarget) {
    _classCallCheck(this, EffectComposer);

    var renderTarget = _renderTarget;
    this.renderer = renderer;

    if (renderTarget === undefined) {
      var parameters = {
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        format: THREE.RGBAFormat,
        stencilBuffer: false
      };
      var size = renderer.getSize(new THREE.Vector2());
      this._pixelRatio = renderer.getPixelRatio();
      this._width = size.width;
      this._height = size.height;
      renderTarget = new THREE.WebGLRenderTarget(this._width * this._pixelRatio, this._height * this._pixelRatio, parameters);
      renderTarget.texture.name = 'EffectComposer.rt1';
    } else {
      this._pixelRatio = 1;
      this._width = renderTarget.width;
      this._height = renderTarget.height;
    }

    this.renderTarget1 = renderTarget;
    this.renderTarget2 = renderTarget.clone();
    this.renderTarget2.texture.name = 'EffectComposer.rt2';
    this.writeBuffer = this.renderTarget1;
    this.readBuffer = this.renderTarget2;
    this.renderToScreen = true;
    this.passes = [];
    this.copyPass = new ShaderPass(CopyShader);
    this.clock = new THREE.Clock();
  }

  _createClass(EffectComposer, [{
    key: "swapBuffers",
    value: function swapBuffers() {
      var tmp = this.readBuffer;
      this.readBuffer = this.writeBuffer;
      this.writeBuffer = tmp;
    }
  }, {
    key: "addPass",
    value: function addPass(pass) {
      this.passes.push(pass);
      var size = this.renderer.getDrawingBufferSize(new THREE.Vector2());
      pass.setSize(size.width, size.height);
    }
  }, {
    key: "insertPass",
    value: function insertPass(pass, index) {
      this.passes.splice(index, 0, pass);
    }
  }, {
    key: "isLastEnabledPass",
    value: function isLastEnabledPass(passIndex) {
      for (var i = passIndex + 1; i < this.passes.length; i += 1) {
        if (this.passes[i].enabled) {
          return false;
        }
      }

      return true;
    }
  }, {
    key: "render",
    value: function render() {
      var deltaTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.clock.getDelta();
      // deltaTime value is in seconds
      var currentRenderTarget = this.renderer.getRenderTarget();
      var maskActive = false;
      var pass;
      var i;
      var il = this.passes.length;

      for (i = 0; i < il; i += 1) {
        pass = this.passes[i];

        if (pass.enabled !== false) {
          pass.renderToScreen = this.renderToScreen && this.isLastEnabledPass(i);
          pass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime, maskActive);

          if (pass.needsSwap) {
            if (maskActive) {
              var context = this.renderer.context;
              context.stencilFunc(context.NOTEQUAL, 1, 0xffffffff);
              this.copyPass.render(this.renderer, this.writeBuffer, this.readBuffer, deltaTime);
              context.stencilFunc(context.EQUAL, 1, 0xffffffff);
            }

            this.swapBuffers();
          }
        }

        if (pass instanceof MaskPass) {
          maskActive = true;
        } else if (pass instanceof ClearMaskPass) {
          maskActive = false;
        }
      }

      this.renderer.setRenderTarget(currentRenderTarget);
    }
  }, {
    key: "reset",
    value: function reset(_renderTarget) {
      var renderTarget = _renderTarget;

      if (renderTarget === undefined) {
        var size = this.renderer.getSize(new THREE.Vector2());
        this._pixelRatio = this.renderer.getPixelRatio();
        this._width = size.width;
        this._height = size.height;
        renderTarget = this.renderTarget1.clone();
        renderTarget.setSize(this._width * this._pixelRatio, this._height * this._pixelRatio);
      }

      this.renderTarget1.dispose();
      this.renderTarget2.dispose();
      this.renderTarget1 = renderTarget;
      this.renderTarget2 = renderTarget.clone();
      this.writeBuffer = this.renderTarget1;
      this.readBuffer = this.renderTarget2;
    }
  }, {
    key: "setSize",
    value: function setSize(width, height) {
      this._width = width;
      this._height = height;
      var effectiveWidth = this._width * this._pixelRatio;
      var effectiveHeight = this._height * this._pixelRatio;
      this.renderTarget1.setSize(effectiveWidth, effectiveHeight);
      this.renderTarget2.setSize(effectiveWidth, effectiveHeight);

      for (var i = 0; i < this.passes.length; i += 1) {
        this.passes[i].setSize(effectiveWidth, effectiveHeight);
      }
    }
  }, {
    key: "setPixelRatio",
    value: function setPixelRatio(pixelRatio) {
      this._pixelRatio = pixelRatio;
      this.setSize(this._width, this._height);
    }
  }]);

  return EffectComposer;
}();

exports.ClearMaskPass = ClearMaskPass;
exports.ClearPass = ClearPass;
exports.CopyShader = CopyShader;
exports.MaskPass = MaskPass;
exports.Pass = Pass;
exports.RenderPass = RenderPass;
exports.RenderingPass = RenderingPass;
exports.ShaderPass = ShaderPass;
exports.TexturePass = TexturePass;
exports.default = EffectComposer;
